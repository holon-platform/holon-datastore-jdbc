[[JDBCDatastore]]
== JDBC Datastore

The `holon-datastore-jdbc` artifact is the main entry point to use the JDBC `Datastore` API implementation.

_Maven coordinates_:
[source, xml, subs="attributes+"]
----
<groupId>com.holon-platform.jdbc</groupId>
<artifactId>holon-datastore-jdbc</artifactId>
<version>{revnumber}</version>
----

The link:{apidir}/com/holonplatform/datastore/jdbc/JdbcDatastore.html[JdbcDatastore^] interface represents the *JDBC Datastore* API implementation, extending the core `Datastore` API.

The `JdbcDatastore` API, besides the standard `Datastore` API operations, provides methods to:

* Create and configure a `JdbcDatastore` API instance, using the provided _builder_.
* Directly working with `JdbcDatastore` managed _connections_, represented by the standard JDBC connection interface (`java.sql.Connection`). See <<JdbcDatastoreAPI>>.

IMPORTANT: If you want to reach the goal of a *_complete abstraction_* from the persistence store technology and the persistence model, the core `Datastore` API interface should be used instead of the specific `JdbcDatastore` API by your application code. This way, the concrete `Datastore` API implementation may be replaced by a different one at any time, without any change to the codebase.

[[JDBCDatastoreSetup]]
=== Setup and configuration

To create a *JDBC Datastore* instance, the `builder()` static method of the `JdbcDatastore` API can be used to obtain the JDBC Datastore _builder_ API. 

The JDBC Datastore builder provides a `JdbcDatastore` instance:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=builder1,indent=0]
----
<1> Obtain the JDBC Datastore builder to configure and create a new JDBC Datastore instance

But, as stated in the previous section, to reach the goal of a *complete abstraction* from the persistence store technology and the persistence model, the core `Datastore` API interface should be used by your application code, instead of the specific `JdbcDatastore` API.

So you can simply obtain the JDBC Datastore implementation as a core `Datastore` API implementation:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=builder2,indent=0]
----
<1> Obtain the JDBC Datastore builder to configure and create a new JDBC Datastore instance and expose it as core `Datastore` API type 

==== Common Datastore configuration options

The JDBC Datastore builder API extends the core `Datastore` builder API, which provides common Datastore configuration settings as listed below.

|===
|Builder method |Arguments |Description

|`dataContextId`
|The _data context id_ `String` value
|Set the _data context id_ to which the Datastore is bound. Can be used, for example, to declare configuration properties for multiple Datastore instances. See the link:holon-core#DatastoreDataContextId[Multiple Datastores configuration^] documentation section.

|`traceEnabled`
|`true` or `false`
|Whether to enable Datastore operations _tracing_. When enabled, the JDBC Datastore will log any SQL operation performed using the Datastore API.

|`configuration`
|A `DatastoreConfigProperties` instance
|Set the `DatastoreConfigProperties` type configuration property set instance to use in order to read the Datastore configuration properties. See the link:holon-core#DatastoreConfiguration[Datastore configuration^] documentation section for details. This configuration properties can be used as an alternative for the programmatic configuration performed with the previous builder methods. 
|===

Example of base JDBC Datastore configuration:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup1,indent=0]
----
<1> Set a _data context id_ for the Datastore
<2> Activate operations _tracing_ in log

The configuration properties can also be provided through an external configuration property source, using the properties provided by the link:{coreapidir}/com/holonplatform/core/datastore/DatastoreConfigProperties.html[DatastoreConfigProperties^] property set.

For example, supposing to have a properties file named `datastore.properties` like this:

[source, text]
----
holon.datastore.trace=true
----

We can use it as configuration property source to enable the Datastore _tracing_ mode:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup2,indent=0]
----
<1> Use the `datastore.properties` file as configuration property source

==== `DataSource` configuration

The JDBC Datastore implementation relies on the `javax.sql.DataSource` API to access the concrete data store using JDBC, and the `DataSource` instance to be used must be provided at JDBC Datastore configuration time.

The `DataSource` reference is the only *required* JDBC Datastore configuration attribute and can be provided in two ways:

*1. Direct:*

The concrete `DataSource` implementation can be provided using the JDBC Datastore builder, through the `dataSource(DataSource dataSource)` method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup3,indent=0]
----
<1> Set the `DataSource` instance to use

*2. Indirect:*

A `DataSource` instance can be otained using the link:holon-jdbc.html[Holon Platform JDBC module] `DataSource` configuration facilities through a set of configuration properties, represented by the link:{jdbcapidir}/com/holonplatform/jdbc/DataSourceConfigProperties.html[DataSourceConfigProperties^] property set.

NOTE: See the link:holon-jdbc.html#DataSourceConfigProperties[JDBC module DataSource configuration properties^] documentation to learn about the available `DataSource` configuration properties.

A `DataSourceConfigProperties` instance can be loaded using the link:holon-core.html#ConfigProperty[configuration property providers^] API and provided to the JDBC Datastore builder.

For example, supposing to have a properties file named `datasource.properties` like this:

[source, text]
----
holon.datasource.url=jdbc:h2:mem:test
holon.datasource.username=sa
----

The JDBC Datastore instance can be created in the following way:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup4,indent=0]
----
<1> A `DataSource` instance will be created and configured for the JDBC Datastore using the DataSource configuration properties loaded from the `datasource.properties` file

TIP: See the link:holon-jdbc.html#DataSourceConfiguration[DataSource configuration^] documentation section of the Holon Platform JDBC module for detailed information about the `DataSource` creation and configuration APIs and strategies.

[[DatabasePlatform]]
==== Database platform configuration

For some internal operations, the JDBC Datastore needs to know the concrete _Database platform_ to which the `DataSource` instance is bound (for example _H2_, _MySQL_ and so on). The _Database platform_ is used, for example, to auto-detect the <<Dialect,SQL dialect>> to use if not directly specified at JDBC Datastore configuration time.

The _Database platform_ can be explicitly specified either using:

* The JDBC Datastore `database` builder method, using the link:{jdbcapidir}/com/holonplatform/jdbc/DatabasePlatform.html[DatabasePlatform^] enumeration.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup5,indent=0]
----
<1> Database platform specification

* Or the `holon.datasource.platform` configuration property, if provided in the `DataSource` configuration property set when using the _indirect_ `DataSource` instance configuration, as described in the previous section.

*Database platform auto detection:*

When the _Database platform_ is not explicitly specified, the JDBC Datastore will try to *auto-detect* it, inspecting the JDBC connection URL of the provided `DataSource` instance.

[[Dialect]]
==== SQL Dialect configuration

To ensure operations consistency and efficiency, the JDBC Datastore uses the link:{apidir}/com/holonplatform/jdbc/composer/SQLDialect.html[SQLDialect^] API abstraction in order to resolve each database platform specificity and SQL language difference.

Normally, the `SQLDialect` implementation to use is *auto-detected* by the JDBC Datastore, relying on the  _Database platform_ to which the `DataSource` instance is bound, as described in the previous section.

The `SQLDialect` implementation to use can be also explicitly configured using the JDBC Datastore builder. This can be done in two ways:

*1. `SQLDialect` configuration using the JDBC Datastore builder:*

The SQL dialect to use can be directly configured using the JDBC Datastore builder, using the `dialect(SQLDialect dialect)` or the `dialect(String dialectClassName)` method.

The `SQLDialect` API provides a static methods to obtain the `SQLDialect` for a specific database platform or to directly obtain a specific dialect implementation within the available ones. 

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup6,indent=0]
----
<1> Configure the dialect using a specific dialect implementation
<2> Configure the dialect using the dialect class name

*1. `SQLDialect` configuration using a configuration property:*

The SQL dialect to use can be also configured using the default `holon.datastore.dialect` Datastore configuration property, available from the link:{coreapidir}/com/holonplatform/core/datastore/DatastoreConfigProperties.html[DatastoreConfigProperties^] property set.

The *fully qualified dialect class name* must be provided as property value.

For example, supposing to have a properties file named `datastore.properties` like this:

[source, text]
----
holon.datastore.dialect=com.holonplatform.datastore.jdbc.composer.dialect.H2Dialect
holon.datastore.trace=true
----

We can use it as configuration property source to configure the JDBC Datastore dialect:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup7,indent=0]
----
<1> Use the `datastore.properties` file as configuration property source

[[BuiltinSQLDialects]]
==== Builtin SQL dialects

The Holon JDBC Datastore module provides a set of builtin SQL dialects for the most common database platforms. The currently available SQL dialect implementations are:

|===
|Database platform |Dialect class |Supported versions

|DB2
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/DB2Dialect.html[DB2Dialect^]
|8 and higher

|Derby
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/DerbyDialect.html[DerbyDialect^]
|10.5 and higher

|H2
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/H2Dialect.html[H2Dialect^]
|1.4 and higher

|HyperSQL (HSQLDB)
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/HSQLDialect.html[HSQLDialect^]
|2.0.0 and higher

|Informix
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/InformixDialect.html[InformixDialect^]
|11 and higher

|MySQL
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/MySQLDialect.html[MySQLDialect^]
|4.1 and higher

|MariaDB
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/MariaDBDialect.html[MariaDBDialect^]
|5.5 and higher

|Oracle Database
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/OracleDialect.html[OracleDialect^]
|9i and higher

|PostgreSQL
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/PostgreSQLDialect.html[PostgreSQLDialect^]
|8.2.5 and higher

|Microsoft SQL Server
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/SQLServerDialect.html[SQLServerDialect^]
|2005 or higher

|SAP HANA
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/HANADialect.html[HANADialect^]
|1.0 SPS12 and higher

|SQLite
|link:{apidir}/com/holonplatform/datastore/jdbc/composer/dialect/SQLiteDialect.html[SQLiteDialect^]
|3.0.7 and higher
|===

[[IdentifierResolutionStrategy]]
==== Identifier resolution strategy

For some of its internal operations, the JDBC Datastore needs to know the actual table *primary key* to ensure consistency, for example for the `save` Datastore API operation, which performs an _insert_ type operation if a row is not present or an _update_ type operation otherwise.

Any standard `Datastore` API operation relies on the Holon Platform property model to represent the data model, using the `PropertyBox` API to receive and provide the data model attributes values. 

To ensure consistency for operations which have to _identify_ a `PropertyBox` instance against the concrete data model (in the JDBC world, the _row_ of a table), the JDBC Datastore needs to know which properties of the `PropertyBox` property set have to be considered as *identifier properties*, if any. This way, the identifier property values can be used to implement a consistent strategy to map the `PropertyBox` instances to the proper table _rows_.

The JDBC Datastore *identifier resolution strategy* defines how this is accomplished, and it is represented by the link:{apidir}/com/holonplatform/datastore/jdbc/config/IdentifierResolutionStrategy.html[IdentifierResolutionStrategy^] enumeration.

The available identifier resolution strategies are:

|===
|Strategy |Description

|`IDENTIFIER_PROPERTIES`
|Use the `PropertySet` *identifier properties* as `PropertyBox` identifier properties. See link:holon-core.html#IdentifierProperties[PropertySet identifier properties] for details.

|`TABLE_PRIMARY_KEY`
|Use the database table *primary key* to obtain the `PropertyBox` identifier properties.

|`AUTO`
|Use the `IDENTIFIER_PROPERTIES` strategy when the `PropertyBox` property set provides configured identifier properties, otherwise use the `TABLE_PRIMARY_KEY` strategy.
|===

The `AUTO` identifier resolution strategy is the *default* strategy adopted by the JDBC Datastore.

To configure a specific identifier resolution strategy, the JDBC Datastore builder API can be used, through the `identifierResolutionStrategy` method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup8,indent=0]
----
<1> Set the identifier resolution strategy to `TABLE_PRIMARY_KEY`

==== JDBC connection handler

The JDBC Datastore builder allows to configure the JDBC connection lifecycle through the link:{jdbcapidir}/com/holonplatform/jdbc/JdbcConnectionHandler.html[JdbcConnectionHandler^] API. 

When a custom implementation is provided, the `getConnection` and `releaseConnection` methods of the `JdbcConnectionHandler` API will be use to obtain a JDBC connection and to release it, respectively.

The default JDBC connection handler used by the JDBC Datastore simply uses the `getConnection()` method of the `DataSource` to obtain a connection and the `Connection.close()` method to release it.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=setup9,indent=0]
----
<1> Configure a custom `JdbcConnectionHandler` for the JDBC Datastore

[[NamingConventions]]
=== Data model attributes naming conventions

The JDBC Datastore relies on the following conventions regarding the mappings between the Holon Platform _property model_ and the concrete JDBC data model (i.e. the RDMBS schema):

* A *link:holon-core.html#DataTarget[DataTarget^] name* is mapped to a RDBMS *table (or view) name*.

* A *`Path` name* (and so a link:holon-core.html#PathProperty[PathProperty^] path name) is mapped to a RDBMS table (or view) *column name*.

NOTE: The `SQLDialect` in use could decide to apply some manipulation operations to the DataTarget or Path names in order to properly match the database schema elements names. For example, it could apply uppercase transformations if the undelying RDBMS only supports uppercase schema objects names.

For example, given a _table_ definition as follows:

[source, sql]
----
create table test (
  code numeric(20) primary key, 
  text varchar(100)
)
----

The property model will be defined simply using the table and column names:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=naming1,indent=0]
----
<1> Map the `ID` property to the `code` path name (i.e. the table column name)
<2> Map the `VALUE` property to the `text` path name (i.e. the table column name)
<3> The `TEST` PropertySet is the `test` table schema representation. Furthermore, the `ID` property is configured as the property set identifier property
<4> The `TARGET` DataTarget is defined using the `test` name, which corresponds to the database table name

Now the `Datastore` API can be used to manage the `test` table data:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=naming2,indent=0]
----
<1> Create a JDBC `Datastore` API instance
<2> Save a `test` table row (insert if not exists, update otherwise) with the given property values
<3> Query the `test` table where the `ID` property value (i.e. the `code` table column value) is greater or equal to 1 and obtain the table rows as a Stream of `PropertyBox` values
<4> Query the `test` table and obtain a list of the `VALUE` property values (i.e. the `text` table column value), ordering ascending by the `ID` property value
<5> Execute a _bulk_ delete operation, removing all the rows with the `ID` property value (i.e. the `code` table column value) greater than 0

[[DataPathMappings]]
==== Data path mappings

The JDBC Datastore fully supports the link:holon-core.html#DataMappable[DataMappable^] API, which can be used to provide a _mapping_ between a data related object path name and the actual path name to be used with the concrete data model schema.

When the `getDataPath()` method of a `DataMappable` type object returns a non empty value, such value will be used as actual *data path*, i.e. as RDBMS schema object name, instead of the default path name with which the object was configured.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=mapping,indent=0]
----
<1> In this case, the `str` table column name will be used instead of `propertyName` when the property is involved in persistence related JDBC Datastore operations

This can be useful, for example, when an existing data model representation wants to used with a JDBC Datastore and the path property names do not match the actual RDBMS data model schema names.

As an example, we suppose to have a JPA entity model definition that we want to use as property model definition with a JDBC Datastore implementation. 

If we don't want to define a brand new property model, through a `PathProperty` set declaration, the link:holon-core.html#BeanIntrospector[Bean introspection^] API can be used to obtain a link:holon-core.html#BeanPropertySet[BeanPropertySet^] from the JPA entity definitions. But this way the `PathProperty` path names of the `BeanPropertySet` will be the _JPA entity Bean property names_, and it is not assured that they match the RDBMS schema objects names. In particular, if the `@Column(name="xxx")` is used on the Bean properties.

The *data path* mapping can be used to provide the actual data attribute name for the properties of the bean property set, in this case using the `name` attribute of the JPA `@Column` annotation.

We can use the link:holon-jpa.html[Holon Platform JPA module^] to automatically map the `name` attribute of the JPA `@Column` annotation in the corresponding *data path* value of the bean property set `PathProperty`. Just ensure that the `holon-jpa-bean-processors` artifact is present in classpath.

At this point, the bean introspection API will use the provided link:holon-jpa.html#JPAPostProcessors[JPA bean post processors^] to automatically configure the data path mapping in the properties, and the JDBC Datastore API can be seamlessy used, without any additional configuration.

For example, given the following JPA entity definition:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=mapping2,indent=0]
----
<1> Create a `BeanPropertySet` using the entity class
<2> Create a `DataTarget` for the entity class: the `name` attribute of the JPA `@Table` annotation will be used to configure a *data path* for the bean data target using the `test` table name

Since the `name` attribute of the JPA `@Column` annotations will be setted as *data path* property values at bean introspection time, the `BeanPropertySet` properties can be now used with a JDBC Datastore API just like in the previous example:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=mapping3,indent=0]
----
<1> Create a JDBC `Datastore` API instance
<2> Save a `test` table row (insert if not exists, update otherwise) with the given property values
<3> Query the `test` table where the `id` property value (i.e. the `code` table column value) is greater or equal to `1` and obtain the table rows as a Stream of `PropertyBox` values

[[SQLDataTypes]]
=== SQL data types mapping

When the Java type is _serialized_ as a SQL data type (for example when used as query parameter) or a SQL data type is _deserialized_ as a Java type (for example to map it as a `Property` value), the JDBC conventions are used to perform the type mapping.

When a SQL type has not a direct Java type representation, the following conventions are used:

.SQL types mapping
|===
|SQL type |Supported Java types

|CLOB
a|`java.lang.String`, `java.io.Reader`

|BLOB
a|`byte[]`, `java.io.InputStream`
|===

.Java types mapping
|===
|Java type |SQL type |Notes

a|`java.lang.Enum`
|INTEGER
|By default, the ordinal enum value is used for the mapping

a|`java.time.LocalDate`
|DATE
|A specific SQL dialect could use a different data type and perform value manipulation if required by the specific SQL type semantic

a|`java.time.LocalTime`
|TIME
|A specific SQL dialect could use a different data type and perform value manipulation if required by the specific SQL type semantic

a|`java.time.LocalDateTime`
|TIMESTAMP
|A specific SQL dialect could use a different data type and perform value manipulation if required by the specific SQL type semantic
|===

[[Relational-expressions]]
=== Relational expressions

As link:holon-core.html#RelationalDatastores[relational Datastore^], the JDBC `Datastore` API supports core _relational expressions_ for data access and manipulation:

*1. Sub-query:*

The link:{apidir}/com/holonplatform/core/datastore/relational/SubQuery.html[SubQuery^] interface can be used to represent a _sub-query_,  which can be used in a query definition to express query restrictions (filters) that involve a sub-query as filter operand.

See the core link:holon-core.html#subquery[sub query expression documentation^] for further information on sub query expressions.

*2. Alias and Joins:*

The link:{apidir}/com/holonplatform/core/datastore/relational/RelationalTarget.html[RelationalTarget^] interface can be used to declare *alias* and *joins* for a `DataTarget` expression.

See the core link:holon-core.html#joins[alias and joins documentation^] for further information on alias and join expressions.

[[AutoGeneratedIds]]
=== Auto-generated ids

The JDBC Datastore API supports the retrieving of auto-generated id column values, if supported by the JDBC driver in use.

The auto-generated id values can be obtained from the `OperationResult` object, returned by Datastore data manipulation operations, through the `getInsertedKeys()` and related methods.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=ids1,indent=0]
----
<1> Perform a _insert_ type operation using the `Datastore` API
<2> Get the auto-generated keys as a Map of key `Path` representation and key value
<3> Get the auto-generated key value for the `ID` property, if available
<4> Get the first auto-generated key value, if available, expecting it of `Long` type

The default *BRING_BACK_GENERATED_IDS* `WriteOption` can be provided to the `Datastore` API operation to bring back any auto-generated key value into the `PropertyBox` instance which was the subject of the operation, if a corresponding `PathProperty` (using the path name) is available in the `PropertyBox` property set.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=ids2,indent=0]
----
<1> The `key` column is supposed to be auto-generated by the database
<2> Create the `PropertyBox` value to insert, not providing the `key` value
<3> Perform the _insert_ operation, providing the *BRING_BACK_GENERATED_IDS* write option
<4> The `KEY` property value of the inserted `PropertyBox` is updated with the auto-generated key value, if available

[[CustomSQLFilterSort]]
=== Custom SQL filters and sorts

The JDBC `Datastore` API supports custom *SQL* filters and sorts expressions, i.e. `QueryFilter` and `QuerySort` type expressions for which the *SQL statement* that represents the `WHERE` and `ORDER BY` conditions is directly provided.

IMPORTANT: Since this kind of expressions accept SQL statements without performing any validation or parsing, you must pay maximum attention using them, since this way the code can be exposed to security concerns such as *SQL injection type attacks*.

==== WhereFilter

The link:{apidir}/com/holonplatform/datastore/jdbc/WhereFilter.html[WhereFilter^] interface is a `QueryFilter` representing a portion of the SQL `WHERE` clause expression.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=where1,indent=0]
----
<1> Create a `WhereFilter`, providing the SQL statement to be included as is in the query `WHERE` clause
<2> The `QueryFilter` can now be used in Datastore expressions just like any other filter expression

The `WhereFilter` expression supports *query parameters*, which must be expressed in the SQL statement using the default `?` placeholder. The parameters values can be setted using the `create` WhereFilter builder method:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=where2,indent=0]
----
<1> Create a `WhereFilter` providing the SQL statement (using the `?` parameter placeholder)  and `John` as parameter value

NOTE: The SQL `?` parameter placeholders are replaced with the parameters values in the same order they are provided in the `create` WhereFilter builder method

==== OrderBySort

The link:{apidir}/com/holonplatform/datastore/jdbc/OrderBySort.html[OrderBySort^] interface is a `QuerySort` representing a portion of SQL `ORDER BY` clause expression.

An `OrderBySort` expression can be created using the `create` builder method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=orderby,indent=0]
----
<1> Create a SQL order by expression to order by the `id` value ascending and the `name` value descending
<2> The `QuerySort` can now be used in Datastore expressions just like any other sort expression

[[Transactions]]
=== Transactions management

The JDBC `Datastore` API implementation is link:holon-core.html#TransactionalDatastores[transactional^], so it supports *transactions* management through the link:{coreapidir}/com/holonplatform/core/datastore/transaction/Transactional.html[Transactional^] API, which can be used to manage transactions at a higher level, in an abstract and implementation-independent way.

See the link:holon-core.html#TransactionalDatastores[Transactional Datastore^] documentation section for information on transactions management with the `Transactional` API.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastore.java[tag=transactional,indent=0]
----
<1> Obtain the `Transactional` API to execute one or more Datastore operation within a transaction
<2> Commit the transaction
<3> Obtain the `Transactional` API to execute the Datastore operation within a transaction and return a value
<4> The transaction is configured with the _auto commit_ mode, this way the transaction is automatically committed at the transactional operation end if no error occurred

[[JdbcDatastoreAPI]]
=== `JdbcDatastore` API

The specialized link:{apidir}/com/holonplatform/datastore/jdbc/JdbcDatastore.html[JdbcDatastore^] API, which extends the standard `Datastore` API, makes available an additional methods through the link:{apidir}/com/holonplatform/datastore/jdbc/composer/ConnectionHandler.html[ConnectionHandler^] interface to *execute an operation using a Datastore managed JDBC connection*.

The JDBC Datastore will take care of connection providing and finalization (i.e. connection closing operations).

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreApi.java[tag=connection,indent=0]
----
<1> Execute an operation using a JDBC Datastore managed connection
<2> Execute an operation using a JDBC Datastore managed connection and return a `String` type result

IMPORTANT: If you want to reach the goal of a *_complete abstraction_* from the persistence store technology and the persistence model, the core `Datastore` API interface should be used instead of the specific `JdbcDatastore` API by your application code. This way, the concrete `Datastore` API implementation may be replaced by a different one at any time, without any change to the codebase.

[[JDBCDatastoreExtension]]
=== Extending the JDBC Datastore API

[[JDBCExpressionResolvers]]
=== Expression resolvers

The `Datastore` API can be extended using the `ExpressionResolver` API, to add new expression resolution strategies, modify existing ones and to handle new `Expression` types.

NOTE: See the link:holon-core.html#DatastoreExpressionResolverExtension[Datastore API extension] documentation section for details.

==== JDBC Expression resolvers registration

A new `ExpressionResolver` can be registered in the JDBC `Datastore` API in two ways:

*1. Using the JDBC `Datastore` API instance:*

An `ExpressionResolver` can be registered either using the `Datastore` _builder_ API at Datastore configuration time:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expreg1,indent=0]
----
<1> Register and new `ExpressionResolver`

Or using the `Datastore` API itself, which extends the `ExpressionResolverSupport` API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expreg2,indent=0]
----
<1> Register and new `ExpressionResolver`

*2. Automatic registration using _Java service extensions_:*

The JDBC Datastore supports `ExpressionResolver` automatic registration using the link:{apidir}/com/holonplatform/datastore/jdbc/config/JdbcDatastoreExpressionResolver.html[JdbcDatastoreExpressionResolver^] base type and the default _Java service extensions_ modality.

To automatically register an `ExpressionResolver` this way, a class implementing `JdbcDatastoreExpressionResolver` has to be created and its fully qualified name must be specified in a file named `com.holonplatform.datastore.jdbc.config.JdbcDatastoreExpressionResolver`, placed in the `META-INF/services` folder in classpath.

When this registration method is used, the expression resolvers defined this way will be registered for *any JDBC `Datastore` API instance*.

==== Specific expression resolvers registration

All the default `Datastore` API operation representations supports *operation specific* expression resolvers registration, through the `ExpressionResolverSupport` API.

An `ExpressionResolver` registered for a specific `Datastore` API operation execution will be available only for the execution of that operation, and will be ignored by any other `Datastore` API operation.

For example, to register an expression resolver only for a single `Query` execution, the `Query` builder API can be used:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expreg3,indent=0]
----
<1> Register an expression resolver only for the specific `Query` operation definition

==== Expression resolvers priority

According to the standard convention, the `javax.annotation.Priority` annotation can be used on `ExpressionResolver` classes to indicate in what order the expression resolvers bound to the same _type resolution pair_ (i.e. the expression type handled by a resolver and the target expression type into which it will be resolved) must be applied.

The less is the `javax.annotation.Priority` number assigned to a resolver, the higher will be it's priority order.

All the default JDBC Datastore expression resolvers have the _minimum_ priority order, allowing to override their behavior and resolution strategies with custom expression resolvers with a higher assigned priority order (i.e. a priority number less then `Integer.MAX_VALUE`).

==== Expression validation

The internal JDBC Datastore _SQL composer engine_ will perform *validation* on any `Expression` instance to resolve and each corresponding resolved `Expression` instance, using the default expression `validate()` method.

So the `validate()` method can be used to implement custom expression validation logic and throw an `InvalidExpressionException` when validation fails.

==== JDBC Datastore expressions

Besides the standard link:holon-core.html#DatastoreExpressionResolverExtension[Datastore API expressions], such as `DataTarget`, `QueryFilter` and `QuerySort`, which can be used to extend the `Datastore` API with new expression implementations and new resolution strategies, the JDBC `Datastore` API can be extended using a set of *specific SQL resolution expressions*, used by the internal _SQL composer engine_ to implement the resolution and composition strategy to obtain SQL statements from the `Datastore` API meta-language expressions.

These SQL expression are available from the `com.holonplatform.datastore.jdbc.composer.expression` package of the `holon-datastore-jdbc-composer` artifact.

The link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLExpression.html[SQLExpression^] is the expression which represents an _SQL statement part_, used to compose the actual SQL statement which will be executed using the JDBC API. So this is the _final_ target expression used by the _SQL composer engine_ to obtain a SQL statement part from other, more abstract, expression types.

The `SQLExpression` type can be used to directly resolve an abstract `Datastore` API expression into a SQL statement part.

For example, supposing to have a `KeyIs` class which represents a `QueryFilter` expression type to represent the expression _"the `key` column name value is equal to a given Long type value"_:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expres1,indent=0]
----

We want to create an `ExpressionResolver` class to resolve the `KeyIs` expression directly into a *SQL WHERE statemet part*, using the `SQLExpression` type. Using the convenience `create` method of the `ExpressionResolver` API, we can do it in the following way:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expres2,indent=0]
----
<1> Expression type to resolve
<2> Target expression type
<3> Expression resolution logic: since we resolve the `KeyIs` expression directly into `SQLExpression` type, the SQL WHERE clause part is provide

After the `ExpressionResolver` is registered in the `Datastore` API, the new `KeyIs` expression can be used in the `Datastore` API operations which support the `QueryFilter` expression type just like any other filter expression. For exmaple, in a `Query` expression:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=expres3,indent=0]
----
<1> Register the new expression resolver
<2> Use the `KeyIs` expression in a query definition

The _SQL composer engine_ will translate the given `KeyIs` expression in the SQL WHERE statement part `key = 1`, using the previously defined expression resolver.

Other expression types are used to represent elements of a query or a Datastore operation, to be resolved into a _final_ `SQLExpression` type. These expression types often represent an _intermediate_ expression type, between the highest abstract layer (i.e. an expression of the `Datastore` API meta-language) and the final SQL statement part representation (i.e. the  `SQLExpression` type).

Some examples are:

* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLLiteral.html[SQLLiteral^] to represent a _literal_ value.
* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLParameter.html[SQLParameter^] to represent a _parameter_ value.
* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLFunction.html[SQLFunction^] to represent a _SQL function_.
* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLProjection.html[SQLProjection^] to represent a _SQL SELECT_ projection.
* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLStatement.html[SQLStatement^] to represent a full _SQL statement_ with parameters support.
* link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLQueryDefinition.html[SQLQueryDefinition^] and link:{apidir}/com/holonplatform/datastore/jdbc/composer/expression/SQLQuery.html[SQLQuery^] to represent the definition of a _SQL query_ and the query statement representation with the `SQLResultConverter` to use to covert the query results in the expected Java type.

For example, let's see how the `SQLFunction` expression can be used as an _intermediate_ SQL expression type to define a new SQL _function_.

We want to define a *IfNull* function, which returns a _fallback_ value expression when a given _expression_ is _null_, following the syntax of the link:https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#function_ifnull[MySQL IFNULL function^].

We will use the `QueryFunction` expression type to represent the function, since it is the default _function_ expression representation of the `Datastore` API.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreFunction.java[tag=function1,indent=0]
----
<1> The _nullable_ expression representation
<2> The _fallback_ expression representation to be returned when the first expression value is _null_ 
<3> Convenience constructor to accept a _constant_ expression value as fallback expression
<4> Validate the arguments
<5> The two function _arguments_ will be the _nullable_ expression and the _fallback_ expression

Now we create an expression resolver to resolve the `QueryFunction` expression into a *`SQLFunction` intermediate SQL expression type*:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreFunction.java[tag=function2,indent=0]
----
<1> Use the `SQLFunction` `create` method to provide the SQL function representation using the function arguments. The function arguments are already provided by the SQL composition engine as serialized SQL expression tokens, according to the actual arguments expression types

Now the function can be registered in the `Datastore` API and used the same way as any other `QueryFunction` expression implementation.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreFunction.java[tag=function3,indent=0]
----
<1> Register the `IfNull` function expression resolver in Datastore
<2> The `IfNull` function is used to provide a fallback `(fallback)` value in a query projection for the `STR` String property value

==== JDBC Expression resolution context

The JDBC `Datastore` API makes available an extension of the standard expression `ResolutionContext`, to provide a set of configuration attributes and SQL resolution context specific operations. This resolution context extension is represented by the link:{apidir}/com/holonplatform/datastore/jdbc/composer/SQLCompositionContext.html[SQLCompositionContext^] API.

When used within the JDBC `Datastore` API, the `ResolutionContext` provided to the registered expresion resolvers is `SQLCompositionContext` for any JDBC `Datastore` API standard operation. To obtain a `SQLCompositionContext`, the `isSQLCompositionContext` method can be used.

The link:{apidir}/com/holonplatform/datastore/jdbc/composer/SQLStatementCompositionContext.html[SQLStatementCompositionContext^] API is a further context extension which provides methods related to SQL _statements_ composition. It can be obtained from a `SQLCompositionContext` through the `isStatementCompositionContext()` method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=context1,indent=0]
----
<1> Let's suppose we are implementing an expression resolver resolution method
<2> Check and obtain the current `ResolutionContext` as a `SQLCompositionContext`
<3> As an example, the current `SQLDialect` is requested
<4> If the context is a SQL _statement_ resolution context, it can be obtained as a `SQLStatementCompositionContext`
<5> Add a _named_ parameter to the current SQL statement context

[[CommodityFactories]]
=== Commodity factories

The JDBC `Datastore` API supports _Datastore commodities_ registration using the link:{apidir}/com/holonplatform/datastore/jdbc/config/JdbcDatastoreCommodityFactory.html[JdbcDatastoreCommodityFactory^] type.

NOTE: See the link:holon-core.html#DatastoreCommodities[Datastore commodities definition and registration] documentation section to learn how the _Datastore commodity_ architecture can be used to provide extensions to the default `Datastore` API.

The `JdbcDatastoreCommodityFactory` type provides a specialized  link:{apidir}/com/holonplatform/datastore/jdbc/config/JdbcDatastoreCommodityContext.html[JdbcDatastoreCommodityContext^] API as Datastore commodity context, to make available a set of JDBC `Datastore` specific configuration attributes and references, for example:

* The `DataSource` instance used by the JDBC `Datastore`.
* The configured (or auto-detected) <<Dialect,SQL dialect>>.
* The configured (or auto-detected) <<DatabasePlatform,database platform>>.
* The configured <<IdentifierResolutionStrategy,identifier resolution strategy>>.
* The available _expression resolvers_ 
* A set of APIs and configuration methods available from the _SQL composer engine_.

Furthermore, it makes available some API methods to invoke some JDBC Datastore operations, such as the `withConnection(ConnectionOperation<R> operation)` method to execute an operation using a Datastore managed JDBC connection or methods to inspect and create other Datastore _commodities_.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=commodity,indent=0]
----
<1> Datastore commodity API
<2> Commodity implementation
<3> Commodity factory implementation

A Datastore commodity factory class which extends the `JdbcDatastoreCommodityFactory` interface can be registered in a JDBC `Datastore` in two ways:

*1. Direct registration using the JDBC `Datastore` API builder:*

The JDBC `Datastore` API supports `DatastoreCommodityFactory` automatic registration using the link:{apidir}/com/holonplatform/datastore/jdbc/config/JdbcDatastoreCommodityFactory.html[JdbcDatastoreCommodityFactory^] type using a _Java service extensions_ based registration method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/jdbc/examples/ExampleJdbcDatastoreExtension.java[tag=factoryreg,indent=0]
----
<1> Register the `MyCommodityFactory` commodity factory in given JDBC `Datastore` implementation

*2. Automatic registration using the  _Java service extensions_:*

To automatically register an commodity factory using the standard _Java service extensions_ based method, a class implementing `JdbcDatastoreCommodityFactory` has to be created and its qualified full name must be specified in a file named `com.holonplatform.datastore.jdbc.config.JdbcDatastoreCommodityFactory`,  placed in the `META-INF/services` folder of the classpath.

When this registration method is used, the commodity factories defined this way will be registered for *any JDBC `Datastore` API instance*.
